name: AI-Powered PR Conflict Resolution

on:
  # Run automatically every 30 minutes
  schedule:
    - cron: '*/30 * * * *'
  # Run when pushed to main
  push:
    branches:
      - main
  # Manual trigger
  workflow_dispatch:

jobs:
  resolve-conflicts:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Set up Git identity
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
      
      - name: Install dependencies
        run: |
          npm install -g @octokit/rest openai

      - name: Identify and resolve PR conflicts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Create Node.js script to handle conflicts
          cat > resolve-conflicts.js << 'EOF'
          const { Octokit } = require('@octokit/rest');
          const { OpenAI } = require('openai');
          const { execSync } = require('child_process');
          const fs = require('fs');
          
          // Initialize clients
          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
          const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
          
          // Repository details
          const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
          
          async function main() {
            console.log('Starting AI-powered conflict resolution...');
            
            // Get all open PRs with the 'codex' label
            const { data: prs } = await octokit.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });
            
            const codexPRs = prs.filter(pr => 
              pr.labels.some(label => label.name === 'codex')
            );
            
            console.log(`Found ${codexPRs.length} open PRs with 'codex' label`);
            
            for (const pr of codexPRs) {
              try {
                console.log(`\nProcessing PR #${pr.number}: ${pr.title}`);
                
                // Check if PR is mergeable
                const { data: prDetail } = await octokit.pulls.get({
                  owner,
                  repo,
                  pull_number: pr.number
                });
                
                if (prDetail.mergeable === true) {
                  console.log(`PR #${pr.number} is mergeable, attempting to merge...`);
                  
                  try {
                    await octokit.pulls.merge({
                      owner,
                      repo,
                      pull_number: pr.number,
                      merge_method: 'squash'
                    });
                    console.log(`Successfully merged PR #${pr.number}`);
                  } catch (mergeError) {
                    console.error(`Error merging PR #${pr.number}:`, mergeError.message);
                  }
                  
                  continue;
                }
                
                if (prDetail.mergeable === false) {
                  console.log(`PR #${pr.number} has conflicts, attempting to resolve...`);
                  
                  // Create a new branch for conflict resolution
                  const resolutionBranch = `conflict-resolution/pr-${pr.number}`;
                  
                  try {
                    // Clean up any existing resolution branch
                    execSync(`git branch -D ${resolutionBranch} 2>/dev/null || true`);
                    
                    // Create and check out resolution branch from base branch
                    execSync(`git checkout ${prDetail.base.ref}`);
                    execSync(`git pull origin ${prDetail.base.ref}`);
                    execSync(`git checkout -b ${resolutionBranch}`);
                    
                    // Try to merge the PR branch
                    try {
                      execSync(`git pull origin ${prDetail.head.ref} --no-rebase`);
                      console.log(`No conflicts detected! This is unexpected since GitHub reported conflicts.`);
                    } catch (mergeError) {
                      // Conflicts occurred as expected
                      console.log(`Conflicts detected, identifying conflicted files...`);
                      
                      // Get list of conflicted files
                      const conflictedFiles = execSync('git diff --name-only --diff-filter=U')
                        .toString()
                        .trim()
                        .split('\n')
                        .filter(file => file.length > 0);
                      
                      console.log(`Found ${conflictedFiles.length} files with conflicts`);
                      
                      // Process each conflicted file
                      for (const file of conflictedFiles) {
                        console.log(`Resolving conflicts in ${file}...`);
                        
                        // Read the conflicted file content
                        const fileContent = fs.readFileSync(file, 'utf8');
                        
                        // Get PR details for context
                        const { data: prFiles } = await octokit.pulls.listFiles({
                          owner,
                          repo,
                          pull_number: pr.number
                        });
                        
                        // Find this file in the PR
                        const prFile = prFiles.find(f => f.filename === file);
                        
                        // Get the file content from both branches for context
                        let baseContent = '';
                        let headContent = '';
                        
                        try {
                          baseContent = execSync(`git show ${prDetail.base.ref}:${file}`, { stdio: 'pipe' }).toString();
                        } catch (error) {
                          console.log(`File doesn't exist in base branch`);
                        }
                        
                        try {
                          headContent = execSync(`git show ${prDetail.head.ref}:${file}`, { stdio: 'pipe' }).toString();
                        } catch (error) {
                          console.log(`File doesn't exist in head branch`);
                        }
                        
                        // Use AI to resolve conflicts
                        const resolvedContent = await resolveConflictsWithAI(
                          file,
                          fileContent,
                          baseContent,
                          headContent,
                          prDetail
                        );
                        
                        // Write the resolved content back to the file
                        fs.writeFileSync(file, resolvedContent);
                        
                        // Stage the resolved file
                        execSync(`git add "${file}"`);
                      }
                      
                      // Commit the resolved conflicts
                      execSync(`git commit -m "Resolve conflicts in PR #${pr.number}"`);
                      
                      // Push the resolution branch
                      execSync(`git push -f origin ${resolutionBranch}`);
                      
                      // Create a PR from the resolution branch to the original PR's head branch
                      const resolutionPrTitle = `Resolve conflicts in PR #${pr.number}`;
                      const resolutionPrBody = `This PR resolves conflicts in PR #${pr.number} using AI-powered conflict resolution.\n\nPlease review the changes and merge if they look good.`;
                      
                      const { data: resolutionPr } = await octokit.pulls.create({
                        owner,
                        repo,
                        title: resolutionPrTitle,
                        head: resolutionBranch,
                        base: prDetail.head.ref,
                        body: resolutionPrBody
                      });
                      
                      console.log(`Created resolution PR #${resolutionPr.number}`);
                      
                      // Add a comment to the original PR
                      await octokit.issues.createComment({
                        owner,
                        repo,
                        issue_number: pr.number,
                        body: `I've created PR #${resolutionPr.number} to resolve the conflicts in this PR. Please review and merge it to resolve the conflicts.`
                      });
                    }
                  } catch (error) {
                    console.error(`Error processing PR #${pr.number}:`, error.message);
                    
                    // Return to main branch
                    execSync('git checkout main');
                    
                    // Add a comment about the failure
                    await octokit.issues.createComment({
                      owner,
                      repo,
                      issue_number: pr.number,
                      body: `I attempted to resolve conflicts but encountered an error: ${error.message}. Manual intervention may be required.`
                    });
                  }
                }
              } catch (error) {
                console.error(`Error processing PR #${pr.number}:`, error.message);
              }
            }
            
            // Create a summary report
            const summary = {
              timestamp: new Date().toISOString(),
              processed: codexPRs.length
            };
            
            fs.writeFileSync('conflict-resolution-summary.json', JSON.stringify(summary, null, 2));
          }
          
          async function resolveConflictsWithAI(file, conflictedContent, baseContent, headContent, prDetail) {
            // Detect conflict markers
            const hasConflicts = conflictedContent.includes('<<<<<<<') && 
                               conflictedContent.includes('=======') && 
                               conflictedContent.includes('>>>>>>>');
            
            if (!hasConflicts) {
              console.log(`No conflict markers found in ${file}, returning unchanged`);
              return conflictedContent;
            }
            
            console.log(`Using AI to resolve conflicts in ${file}...`);
            
            // Prepare context for AI
            const fileExtension = file.split('.').pop().toLowerCase();
            let fileType = 'code';
            let language = '';
            
            // Detect language from file extension
            switch (fileExtension) {
              case 'js':
                language = 'JavaScript';
                break;
              case 'ts':
                language = 'TypeScript';
                break;
              case 'jsx':
              case 'tsx':
                language = 'React';
                break;
              case 'py':
                language = 'Python';
                break;
              case 'java':
                language = 'Java';
                break;
              case 'md':
                language = 'Markdown';
                fileType = 'text';
                break;
              case 'json':
                language = 'JSON';
                break;
              case 'yml':
              case 'yaml':
                language = 'YAML';
                break;
              default:
                language = 'Unknown';
            }
            
            // Split content into conflict sections
            const sections = [];
            let currentPos = 0;
            let conflictStart = conflictedContent.indexOf('<<<<<<<', currentPos);
            
            while (conflictStart !== -1) {
              // Add text before conflict
              if (conflictStart > currentPos) {
                sections.push({
                  type: 'regular',
                  content: conflictedContent.substring(currentPos, conflictStart)
                });
              }
              
              // Find separator and end
              const separatorPos = conflictedContent.indexOf('=======', conflictStart);
              const conflictEnd = conflictedContent.indexOf('>>>>>>>', separatorPos);
              
              if (separatorPos !== -1 && conflictEnd !== -1) {
                // Extract conflict parts
                const ourStart = conflictStart + 7; // Length of '<<<<<<<'
                const ourEnd = separatorPos;
                const theirStart = separatorPos + 7; // Length of '======='
                const theirEnd = conflictEnd;
                
                sections.push({
                  type: 'conflict',
                  ours: conflictedContent.substring(ourStart, ourEnd).trim(),
                  theirs: conflictedContent.substring(theirStart, theirEnd).trim()
                });
                
                currentPos = conflictEnd + 7; // Length of '>>>>>>>'
              } else {
                // Malformed conflict marker, treat as regular text
                sections.push({
                  type: 'regular',
                  content: conflictedContent.substring(conflictStart, conflictStart + 7)
                });
                currentPos = conflictStart + 7;
              }
              
              conflictStart = conflictedContent.indexOf('<<<<<<<', currentPos);
            }
            
            // Add remaining text after last conflict
            if (currentPos < conflictedContent.length) {
              sections.push({
                type: 'regular',
                content: conflictedContent.substring(currentPos)
              });
            }
            
            // Build content for AI prompt
            let promptContent = `You are an expert developer tasked with resolving merge conflicts in a GitHub pull request.
            
File: ${file}
Language: ${language}
File Type: ${fileType}
PR Title: ${prDetail.title}
PR Description: ${prDetail.body || 'No description provided'}

I'll show you the conflicted file with conflict markers. Your task is to resolve each conflict by choosing the correct code or merging the changes intelligently.

For each conflict section, analyze both versions and determine the best resolution based on:
1. The intent of the PR (from title and description)
2. Code correctness and functionality
3. Modern best practices for ${language}
4. Avoiding duplication
5. Maintaining code structure and style

The conflicted file has sections marked with <<<<<<<, =======, and >>>>>>>. 
- Code between <<<<<<< and ======= is from the base branch (main)
- Code between ======= and >>>>>>> is from the PR branch

Here are the conflicts to resolve:\n\n`;
            
            // Add each conflict section
            for (let i = 0; i < sections.length; i++) {
              const section = sections[i];
              
              if (section.type === 'regular') {
                promptContent += `--- Regular Code Section ${i+1} ---\n${section.content}\n\n`;
              } else if (section.type === 'conflict') {
                promptContent += `--- Conflict Section ${i+1} ---\n`;
                promptContent += `Base branch version:\n${section.ours}\n\n`;
                promptContent += `PR branch version:\n${section.theirs}\n\n`;
              }
            }
            
            promptContent += `Provide a fully resolved version of the file with all conflicts resolved. 
Do not include any conflict markers (<<<<<<<, =======, >>>>>>>) in your response.
Start your response with "RESOLVED FILE:" and then provide the complete resolved file content.`;
            
            try {
              // Call OpenAI to resolve conflicts
              const response = await openai.chat.completions.create({
                model: "gpt-4-turbo",
                messages: [
                  { role: "system", content: "You are an expert developer who specializes in resolving merge conflicts." },
                  { role: "user", content: promptContent }
                ],
                temperature: 0.2,
                max_tokens: 4000
              });
              
              const aiResponse = response.choices[0].message.content;
              
              // Extract the resolved content
              const resolvedMarker = "RESOLVED FILE:";
              const markerIndex = aiResponse.indexOf(resolvedMarker);
              
              if (markerIndex !== -1) {
                const resolvedContent = aiResponse.substring(markerIndex + resolvedMarker.length).trim();
                return resolvedContent;
              } else {
                console.error(`AI response doesn't contain the expected marker. Using original content.`);
                return conflictedContent;
              }
            } catch (error) {
              console.error(`Error calling OpenAI API:`, error.message);
              return conflictedContent;
            }
          }
          
          main().catch(error => {
            console.error('Error in main function:', error);
            process.exit(1);
          });
          EOF
          
          # Run the Node.js script
          node resolve-conflicts.js
          
      - name: Upload resolution summary
        uses: actions/upload-artifact@v3
        with:
          name: conflict-resolution-summary
          path: conflict-resolution-summary.json
