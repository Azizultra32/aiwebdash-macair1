name: Extract Conflict Files

on:
  # Run automatically every 30 minutes
  schedule:
    - cron: '*/30 * * * *'
  # Run when pushed to main
  push:
    branches:
      - main
  # Manual trigger
  workflow_dispatch:

jobs:
  extract-conflicts:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Install dependencies
        run: |
          npm install -g @octokit/rest
          
      - name: Extract conflicting files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a script to extract conflicting files
          cat > extract-conflicts.js << 'EOF'
          const { Octokit } = require('@octokit/rest');
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');
          
          // Initialize GitHub client
          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
          
          // Repository details
          const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
          
          async function main() {
            console.log('Extracting conflicting files from PRs...');
            
            // Create directory for conflict files
            const conflictsDir = 'conflicts';
            if (!fs.existsSync(conflictsDir)) {
              fs.mkdirSync(conflictsDir);
            }
            
            // Get all open PRs with the 'codex' label
            const { data: prs } = await octokit.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });
            
            const codexPRs = prs.filter(pr => 
              pr.labels.some(label => label.name === 'codex')
            );
            
            console.log(`Found ${codexPRs.length} open PRs with 'codex' label`);
            
            // Extract conflict details for each PR
            const conflictReport = [];
            
            for (const pr of codexPRs) {
              try {
                console.log(`\nProcessing PR #${pr.number}: ${pr.title}`);
                
                // Get PR details
                const { data: prDetail } = await octokit.pulls.get({
                  owner,
                  repo,
                  pull_number: pr.number
                });
                
                if (prDetail.mergeable === false) {
                  console.log(`PR #${pr.number} has conflicts`);
                  
                  // Create directory for this PR
                  const prDir = path.join(conflictsDir, `pr-${pr.number}`);
                  if (!fs.existsSync(prDir)) {
                    fs.mkdirSync(prDir);
                  }
                  
                  // Create branches directory
                  const branchesDir = path.join(prDir, 'branches');
                  if (!fs.existsSync(branchesDir)) {
                    fs.mkdirSync(branchesDir);
                  }
                  
                  // Create conflicts directory
                  const prConflictsDir = path.join(prDir, 'conflicts');
                  if (!fs.existsSync(prConflictsDir)) {
                    fs.mkdirSync(prConflictsDir);
                  }
                  
                  // Get PR metadata
                  const prMetadata = {
                    number: pr.number,
                    title: pr.title,
                    baseBranch: prDetail.base.ref,
                    headBranch: prDetail.head.ref,
                    description: prDetail.body || '',
                    url: prDetail.html_url
                  };
                  
                  // Save PR metadata
                  fs.writeFileSync(
                    path.join(prDir, 'metadata.json'),
                    JSON.stringify(prMetadata, null, 2)
                  );
                  
                  // Get files from PR
                  const { data: files } = await octokit.pulls.listFiles({
                    owner,
                    repo,
                    pull_number: pr.number
                  });
                  
                  // Save list of files
                  fs.writeFileSync(
                    path.join(prDir, 'files.json'),
                    JSON.stringify(files, null, 2)
                  );
                  
                  // Get base branch version of each file
                  for (const file of files) {
                    try {
                      // Get base version
                      try {
                        const baseContent = execSync(
                          `git show ${prDetail.base.ref}:${file.filename}`,
                          { stdio: 'pipe' }
                        ).toString();
                        
                        // Ensure directory exists
                        const baseDir = path.join(branchesDir, 'base');
                        ensureDirectoryExists(path.join(baseDir, path.dirname(file.filename)));
                        
                        // Save base content
                        fs.writeFileSync(
                          path.join(baseDir, file.filename),
                          baseContent
                        );
                      } catch (error) {
                        console.log(`File ${file.filename} doesn't exist in base branch`);
                      }
                      
                      // Get head version
                      try {
                        const headContent = execSync(
                          `git show ${prDetail.head.ref}:${file.filename}`,
                          { stdio: 'pipe' }
                        ).toString();
                        
                        // Ensure directory exists
                        const headDir = path.join(branchesDir, 'head');
                        ensureDirectoryExists(path.join(headDir, path.dirname(file.filename)));
                        
                        // Save head content
                        fs.writeFileSync(
                          path.join(headDir, file.filename),
                          headContent
                        );
                      } catch (error) {
                        console.log(`File ${file.filename} doesn't exist in head branch`);
                      }
                    } catch (error) {
                      console.error(`Error processing file ${file.filename}:`, error.message);
                    }
                  }
                  
                  // Try to check out the PR and identify conflicting files
                  try {
                    // Create a temporary branch
                    const tempBranch = `temp-${pr.number}-${Date.now()}`;
                    execSync(`git checkout ${prDetail.base.ref}`);
                    execSync(`git checkout -b ${tempBranch}`);
                    
                    // Try to merge PR branch and expect it to fail
                    try {
                      execSync(`git pull origin ${prDetail.head.ref} --no-rebase`);
                      console.log(`No conflicts detected when merging PR #${pr.number}`);
                    } catch (error) {
                      // This is expected - it means there are conflicts
                      
                      // Get list of conflicted files
                      const conflictedFiles = execSync('git diff --name-only --diff-filter=U')
                        .toString()
                        .trim()
                        .split('\n')
                        .filter(file => file.length > 0);
                      
                      console.log(`Found ${conflictedFiles.length} files with conflicts`);
                      
                      // For each conflicted file, extract the conflicted content
                      for (const file of conflictedFiles) {
                        try {
                          // Get conflicted content
                          const conflictContent = fs.readFileSync(file, 'utf8');
                          
                          // Ensure directory exists
                          ensureDirectoryExists(path.join(prConflictsDir, path.dirname(file)));
                          
                          // Save conflicted content
                          fs.writeFileSync(
                            path.join(prConflictsDir, file),
                            conflictContent
                          );
                        } catch (error) {
                          console.error(`Error extracting conflict for ${file}:`, error.message);
                        }
                      }
                      
                      // Save list of conflicted files
                      fs.writeFileSync(
                        path.join(prDir, 'conflicted-files.json'),
                        JSON.stringify(conflictedFiles, null, 2)
                      );
                      
                      // Add to conflict report
                      conflictReport.push({
                        pr: prMetadata,
                        conflictedFiles
                      });
                    }
                    
                    // Clean up
                    execSync('git reset --hard');
                    execSync('git checkout main');
                    execSync(`git branch -D ${tempBranch}`);
                  } catch (error) {
                    console.error(`Error checking out PR #${pr.number}:`, error.message);
                  }
                } else {
                  console.log(`PR #${pr.number} has no conflicts`);
                }
              } catch (error) {
                console.error(`Error processing PR #${pr.number}:`, error.message);
              }
            }
            
            // Save overall conflict report
            fs.writeFileSync(
              path.join(conflictsDir, 'conflict-report.json'),
              JSON.stringify(conflictReport, null, 2)
            );
            
            // Create a markdown report
            let markdownReport = `# PR Conflict Report\n\n`;
            markdownReport += `Generated: ${new Date().toISOString()}\n\n`;
            
            if (conflictReport.length === 0) {
              markdownReport += `No PRs with conflicts found!\n`;
            } else {
              markdownReport += `## Summary\n\n`;
              markdownReport += `Found ${conflictReport.length} PRs with conflicts:\n\n`;
              
              for (const item of conflictReport) {
                markdownReport += `### PR #${item.pr.number}: ${item.pr.title}\n\n`;
                markdownReport += `- URL: ${item.pr.url}\n`;
                markdownReport += `- Base Branch: ${item.pr.baseBranch}\n`;
                markdownReport += `- Head Branch: ${item.pr.headBranch}\n`;
                markdownReport += `- Files with Conflicts (${item.conflictedFiles.length}):\n`;
                
                for (const file of item.conflictedFiles) {
                  markdownReport += `  - \`${file}\`\n`;
                }
                
                markdownReport += `\n`;
              }
            }
            
            // Save markdown report
            fs.writeFileSync(
              path.join(conflictsDir, 'conflict-report.md'),
              markdownReport
            );
          }
          
          function ensureDirectoryExists(directory) {
            if (!fs.existsSync(directory)) {
              fs.mkdirSync(directory, { recursive: true });
            }
          }
          
          main().catch(error => {
            console.error('Error in main function:', error);
            process.exit(1);
          });
          EOF
          
          # Run the script
          node extract-conflicts.js
          
      - name: Upload conflict files
        uses: actions/upload-artifact@v3
        with:
          name: pr-conflict-files
          path: conflicts
          
      - name: Create or update conflict issue
        if: success()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if conflict report exists
          if [ ! -f "conflicts/conflict-report.md" ]; then
            echo "No conflict report found, skipping issue creation"
            exit 0
          fi
          
          # Create or update issue with conflict report
          ISSUE_TITLE="PR Conflict Report"
          ISSUE_BODY=$(cat conflicts/conflict-report.md)
          
          # Check if issue already exists
          EXISTING_ISSUE=$(gh issue list --search "$ISSUE_TITLE" --json number --jq '.[0].number')
          
          if [ -n "$EXISTING_ISSUE" ]; then
            # Update existing issue
            gh issue comment "$EXISTING_ISSUE" --body "## Updated Conflict Report\n\n$ISSUE_BODY"
          else
            # Create new issue
            gh issue create --title "$ISSUE_TITLE" --body "$ISSUE_BODY" --label "conflict-report"
          fi
